{"./":{"url":"./","title":"简介","keywords":"","body":"书名《JavaScript高级程序设计》 "},"第1章 JavaScript简介.html":{"url":"第1章 JavaScript简介.html","title":"第1章 JavaScript简介","keywords":"","body":"第1章 JavaScript简介 "},"第2章 在HTML中使用JavaScript.html":{"url":"第2章 在HTML中使用JavaScript.html","title":"第2章 在HTML中使用JavaScript.md","keywords":"","body":"第2章 在HTML中使用JavaScript "},"第3章 基本概念.html":{"url":"第3章 基本概念.html","title":"第3章 基本概念.md","keywords":"","body":"第3章 基本概念 3.4 数据类型 6种数据类型 Undefined Null Number String Boolean Object 3.4.1 tyiepof操作符 typeof返回值: undefined-值未定义 string-值为字符串 boolean-值为布尔值 number-值为数字 Object-值为对象/null function-值为函数 注意：typeof不是函数 null被认为是一个空的对象引用，原型链中最顶端的 Object.prototype(构造函数原型) 的 __proto__ 指向 null 3.4.2 Undifined类型 Undefined类型只有一个值，即特殊的undefined，使用typeof检测undefined时返回undefined ```js // 声明了变量，但未初始化 let message; let str = undefined; typeof messge; // undefined typeof str; // undefined console.log(message == undefined); // true console.log(str == undefined); // true console.log(message === undefined); // true console.log(str === undefined); // true `注意：对于为定义的变量，typeof 操作符仍然会返回 undefined` ```js // let test console.log(test); // 会报错，提示test is not defined typeof test; // 返回undefined 3.4.3 Null类型 Null类型是第二个只有一个值的类型，即null，null值表示一个空对象指针，所以使用typeof检测null值时返回object let car = null; console.log(typeof car); // object 如果定义的变量准备保存对象，那么最好将对象初始化为null，这样可以直接通过检测null值来判断变量是否已经保存了一个对象的引用。 let car = null; if (car != null) { // do something } 其实 undefined 是派生自 null，所以它们的想等性(==)检测结果为true，但是如果使用严格等于(===)，因为 typeof null 返回 object ，typeof undefined 返回 undefined，二者数据类型不一致，所以使用严格等于判断时返回 false ```js console.log(undefined == null); // true console.log(undefined === null); // false ### 3.4.4 Boolean类型 >`Boolean` 有两个字面值：`true/false`，虽然Boolean只有两个值，但ECMAScript中的所有类型都有与这两个Boolean值等价的值，可以调用`Boolean()`进行转换 ```js let message = 'Hello JS'; let messageBoolean = Boolean(message); console.log(messageBoolean); // true 数据类型 转换为true值 转换为false值 Boolean true false String 任何非空字符串 空字符串 Number 任何非0数值（包括无穷大） 0/NaN Object 任何对象 null Undefined 不适用 undefined 字符串无法与true直接通过==进行判断，无论为正常字符串还是空字符串都返回false；但是字符串1除外。 ```js // String let str = 'Hello JS'; function test(){ if(str == true){ console.log('str == true') } else if(str){ console.log(str) } } test(); // Hello JS console.log(str == true); // false console.log('hello js' == true); // false console.log('' == true); // false console.log(1 == true); // true console.log('1' == true); // true >数字与`true`通过`==`进行判断，只有`1`会返回`true`，其他数字都会返回`false`；但是是如果通过`if(num)`进行判断，任何非`0`数值（包括无穷大）都为`true`，当数值通过严格等于`===`与`true/false`进行判断时全部返回`false`，因为数值为`Number`类型 ```js // Number function test(){ let num1 = 0; let num2 = 1; let num3 = 999; if(!0){ // do something; }; // 0 == false 判断返回false if(0 != false){ // do something }; if(1){ // do something }; // 1 == true 返回true if(1 == true){ // do something }; if(999){ // do something }; // 999 == true 返回false if(999 != true){ // do something } // 正无穷，负无穷 if(Infinity){ // do something } if(-Infinity){ // do something } }; test(); Object 都返回 true ，只有空对象 null 返回 false function test(){ let obj = {}; let data = { name: 'Zzhiren' }; let empty = null; if(obj){ // true // do something } if(data){ // true // do something } if(!empty){ // true // do something } } test(); Undefined 返回 false，undefined 不同通过 == 与 true/false 进行判断 function test(){ let value; if(!value){ // true // do something } if(value == true){ console.log('undefined == true'); }else if(value == false){ console.log('undefined == false'); }else{ console.log('undefined != false && undefined != true'); } } test(); 3.4.5 Number类型 注意：在进行算术计算时，所有八进制和十六进制数都将转换成十进制数进行计算。 1. 浮点数值 浮点数值需要的内存空间为整数值的两倍 ECMAScript会将一些浮点数保存为整数值来节省内存空间 1. 解析为 1 10.0 解析为 `10 浮点数最高精度为17位，浮点数进行算术运算可能会丢失精度 0.1加0.2不等于0.3，而等于0.30000000000000004，所以不要用浮点数做如下的一些测试 // 不要做这样的测试 if(a + b == 0.3){ console.log('a加b等于0.3) } 2. 数值范围 最大值：保存在Number.MAX_VALUE 最小值：保存在Number.MIX_VALUE 3. NaN NaN表示非数值，即（Not a Number），这个数值表示一个本来应该返回数值的操作未返回数值的情况 // 数值除以字符串结果肯定不为数值 console.log(999/'test'); // NaN 4. 数值转换 Number() Boolean 转换成 0/1 null 返回 0 undefined 返回 NaN 字符串 只包含数字（包括正负号），转为十进制数，前面的0被忽略 浮点数转换为浮点数，前面的0被忽略 字符串中包含有效的十六进制格式，则会转换为相等的十进制数 如果字符中包含除上述格式之外的字符，转为NaN 举例：'this is a string' 转换对象 总结： 只要字符串中有非数字（十六进制格式除外），全部转换为NaN 其他进制全部转换为十进制数 数值正负转换后依然保留正负 parseInt() 从字符串第一个字符开始解析，遇到非字符串解析停止，返回非字符串之前的数值 能够识别其他进制，将其他进制转换为十进制数 空字符串返回NaN，Number()则返回0 parseFloat() 只转换十进制，十六进制将转换为0 如果字符串包含的是一个整数格式，则会返回整数 其他规则与parseInt()类型 // Number()， let num1 = Number('Hello JS'); // NaN let num3 = Number('00011'); // 11 let num4 = Number(true); // 1 // parseInt() let num1 = parseInt('123blue'); // 123 let num3 = parseInt('-999'); // -999 let num4 = parseInt('0xf'); // 15 let num5 = parseInt('070', 8); // 56 // 转换空字符串的区别 let num2 = Number(''); // 0 let num2 = parseInt(''); // NaN 3.4.6 String类型 1. 字符字面量 转义字符 这些字符字面量可以出现在字符串中的任意位置，而且也被当作一个字符来解析 字面量 含义 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 走纸换页 \\' 单引号 \\\" 双引号 2. 转换为字符串 注意以下几点 let num1 = null; num1.toString(); // 报错，没有toString()方法 String(num1); // 返回字符串'null' let num2; num2.toString(); // 报错，undefined的值没有toString()方法 String(num2); // 返回字符串 'undefined' 3.4.7 Object类型 创建一个对象 let obj = new Object(); // 不推荐写法 let obj = new Object; // 不推荐写法 let obj = {}; // 推荐写法 所有的对象都源于Object对象 Object的每个实例都具有下列属性和方法 Constructor（构造函数）: 保存用户创建当前对象的函数，上面的例子构造函数就是Object() hasOwnProperty(propertyName): 检查当前对象中是否有某个属性（不检查原型链，只检查当前对象的私有属性） isPrototypeOf(Object): 检查传入的对象是否存在于另一个对象的原型链中 propertyIsEnumerable(propertyName): 检查给定的属性是否能够使用for-in语句来枚举 toLocaleString(): 返回对象的字符串表示，该字符串与执行环境的地区对应 toString(): 返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或布尔值表示 // hasOwnProperty(propertyName) function Man() { this.sex = 'man' } Person.prototype.type = 'person' Man.hasOwnProperty('type'); // false 不检查原型链上的属性 // isPrototypeOf(Object) function Person(){ this.type = 'person' } let person = new Person(); let man = new Person(); console.log(man.type); // man的原型对象存在于Person对象的原型链中 console.log(Person.prototype.isPrototypeOf(man)); // true "},"第4章 变量、作用域和内存问题.html":{"url":"第4章 变量、作用域和内存问题.html","title":"第4章 变量、作用域和内存问题.md","keywords":"","body":"第4章 变量、作用域和内存问题 4.1 基本类型和引用类型的值 按值访问，可以直接操作保存在变量中的实际的值 Undefined Null Boolean Number String 按引用访问 Object 4.1.1 动态的属性 4.1.2 复制变量值 基本类型值（两个变量值一样，当时相互独立） 引用类型值（复制的是引用地址值，相互独立，但两个变量的值仍然指向同一个对象） 4.1.3 传递参数 所有函数的参数都是按值传递的 // 示例1 let num = 100; let obj = {name:'Alice'}; // obj存储着对象的地址值 0x000000 function test(num,obj){ // o 保存着对象的地址 0x000000，与外部的obj指向同一个对象 let n = num; // 100 let o = obj; // 指向 {name:'Alice'} } test(num,obj); // 示例2 function setName(obj) { obj.name = 'Alice'; obj = new Object(); obj.name = 'Tom'; } var person = new Object(); setName(person); console.log(person.name); // Alice setName()的内部obj会在函数执行完成后被销毁 4.1.4 检测类型 typeof 只能检测基本类型，引用类型一律返回 Object instanceof 检测引用类型 instanceof 检测的缺点，只要是引用类型的都属于 Object // instanceof 的缺点 let arr = []; arr instanceof Object; // true arr instanceof Array; // true function test(){ } test instanceof Object; // true 4.2 执行环境及作用域 概念 函数执行环境 执行环境栈 作用域/作用域链 分析执行环境与作用域 分析： 创建 one() 执行环境，压栈 调用 two() ，创建 tow() 执行环境，压栈 调用 three() ，创建 three() 执行环境，压栈 three() 执行完成，出栈，继续执行 tow() two() 执行完成，出栈，继续执行 one() one() 执行完成，出栈 // 执行环境 function one() { console.log('one'); two(); console.log('tow()出栈‘) }; function two() { console.log('创建two()的执行环境，并压栈'); three(); console.log('two'); }; function three() { console.log('创建three()的执行环境，并压栈‘); console.log('three') } one(); // 作用域 function person(){ let type = 'person' function man() { let name = 'Tom'; console.log(type); // 可以访问person的变量 }; function woman() { let height = 170; console.log(type); // 可以访问person的变量 console.log(name); // 会报错，因为无法访问到man的变量 }; man(); woman(); } person(); 总结：js在执行到函数时，会创建执行环境，执行环境中保存着变量对象和作用域链，作用域链中保存可以访问的变量对象的地址，所以当一个函数自身未定义某个变量时，会沿着作用域链查找，当查找到需要的变量时立即停止查找，如果知道查找到全局执行环境还未查询到改变了则会返回未定义。 拓展: 下面函数的打印顺序 function test() { setTimeout(function(){ console.log(1) }, 0); new Promise(function(a, b){ setTimeout(function(){ for(var i=0; i 4.2.1 延长作用域链 try-catch 语句的 catch 块 with 语句 catch 块会在进入catch块时在作用域链前端创建一个新的变量对象，其中包含的是被排除的错误对象的声明 width 会在作用域链前端添加一个变量对象 示例 clickOne clickTwo var withObj = { name: 'withObj' } function one () { let num = 1 try { console.log(num1) } catch (error) { console.log(error) } } function two () { let two = 'two' with(withObj) { console.log(withObj) } } 通过chrome调试工具可以看到scope中新创建的变量对象 4.2.2 没有块级作用域 其他类C语言中被花括号封闭的代码都拥有自己的作用域(称为块级作用域)外部无法访问块级作用域内定义的内容，但JS并没有这样的块级作用域 if(true) { var color = 'blue' } console.log(color) // 'blue' 1.声明变量 const 声明一个 只读 的常量 let 声明的变量不会出现变量提升 var 声明变量会出现变量提升 示例 // 在chrome console 中运行查看效果 const sex = '男' sex = '女' console.log(name) var name = 'Zzhiren' console.log(age) let age = '26' 4.3 垃圾收集 垃圾收集机制的原理：找出不再被使用的变量，定时清除这些变量，释放内存。 标记无用变量的两种策略 标记清除 引用计数 4.3.1 标记清除 标记清除基本原理： 垃圾收集器给所有存储在内存中的变量加上标记 排除使用中的变量，剩余变量将被视为准备删除的变量 垃圾收集器下次运行时会清除被标记的变量占用的内存 哪些变量为使用中的变量 执行环境中的变量，被环境中变量引用的变量都被视为使用中的变量 4.3.2 引用计数 引用计数基本原理： 一个引用类型的 值 被一个变量引用，值 的引用计数 +1 如果一个变量移除了对该 值 的引用，值 的引用计数 -1 当一个值的引用计数微0时，垃圾收集器下次运行时回清除 值 所占用的内存 引用计数存在的问题：循环引用 当两个对象相互引用时会造成循环引用，导致对象已经离开执行环境，但引用计数仍然 >0 ,此时垃圾收集器无法会后对象占用的内存 示例：对象相互引用 let objA = { name: 'Zzhiren' } let objB = { age: '26' } objA.b = objB objB.a = objA 4.3.3 性能问题 IE7出现的性能问题： 早期版本的IE7的垃圾收集器是根据内存分配量运行的，当一个脚本中的变量定义达到了IE7设置的阈值将会触发垃圾收集器的运行 导致的问题： 当一个脚本中定义的变量超过这个阈值且脚本的生命周期未结束时，将会频繁触发垃圾收集器工作，这将会导致IE7的性能问题 解决方案： 垃圾收集器的内存分配量阈值设置一个默认值，当垃圾收集器回收的内存量 低于15% 时，说明当前运行的脚本内存占用较多，调大 阈值(翻倍) ，避免频繁启动垃圾收集器；若垃圾收集器回收的内存量 大于85% 时，说明当前运行的脚本内存占用较少，将 阈值重置为默认值 4.3.4 管理内存 解除引用：针对全局变量使用，将不使用的变量置为 null 释放引用，此时变量将会被标记为待删除变量，下次垃圾收集器运行时将会回收其内存 局部变量在离开其执行环境时会被自动解除引用 "},"第5章 引用类型.html":{"url":"第5章 引用类型.html","title":"第5章 引用类型.md","keywords":"","body":"第5章 引用类型 5.1 Object 类型 创建Object的两种方式 new 操作符创建 对象字面量创建 ```js let person = new Object() person.name = 'Zzhiren' person.sex = '男' let animal = { name: 'Tom', type: '猫' } 访问对象属性的两种方法 * `点` 表示法 * `方括号` 表示法 注意：方括号内容可以是一个变量 ```js // 定义对象变量 let obj = { name: 'Zzhiren', sex: '男', 'first name': 'Z', 'last name': 'zhiren' } // 访问对象属性 console.log(obj.name) console.log(obj.sex) console.log(obj['first name']) // 定义变量存放 ‘last name’ let lastName = 'last name' console.log(obj[lastName]) 5.2 Array 类型 创建Array（数组）的方法 new 操作符（构造函数创建），new 操作符可以省略 字面量表示法 // 创建一个空数组 let newArr = new Array() // 创建衣蛾长度为 20 的数组 let newArr20 = new Array(20) // 创建一个包含 'Zzhiren' 元素的数组 let newArrItem = new Array('Zzhiren') // 字面量方法创建 let arr = [] let arrItem = ['Zzhiren'] 5.2.1 检测数组 Object.prototype.toString.call() 检测数组 instanceof 检测数组 constructor 检测数组 Array.isArray() 检测数组 1. Object.prototype.toString.call() 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [object type] ，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时会返回内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文 let arr = ['My', 'Name', 'is', 'Zzhiren'] arr.toString() // 'My,Name,is,Zzhiren' Object.prototype.toString.call(arr) // '[object Array]' 优点：这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 defined ，且和 Array.isArray 方法一样都能检测出 iframes Object.prototype.toString.call('Zzhiren') // '[object String]' Object.prototype.toString.call(1) // '[object Number]' Object.prototype.toString.call(Symbol(1)) // '[object Symbol]' Object.prototype.toString.call(null) // '[object Null]' Object.prototype.toString.call(undefined) // '[object Undefined]' Object.prototype.toString.call(function(){}) // '[object Function]' Object.prototype.toString.call({name: 'Zzhiren'}) // '[object Object]' 缺点：不能精确判断自定义对象，对于自定义对象只会返回 [object Object] 2. instanceof 用法：arr instanceof Array instanceof 主要用于判断实例是否是由某个对象实例化而来 function obj () {} let obj01 = new obj() console.log(obj01 instanceof obj) let arr = [] // let arr = new Array() console.log(arr instanceof Array) 缺点：instanceof只能在一个全局执行环境中进行判断，当网页中包含多个框架，也就是有多个全局执行环境，就会存在多个Array的构造函数。 此时从一个框架向另一个框架传入一个数组，name传入的数组与在第二个框架中原生创建的数组分别具有不同的构造函数。 3. constructor 用法：arr.constructor === Array Object的每个实例都有构造函数 constructor, 保存用户创建当前对象的函数 function obj () {} let obj01 = new obj() console.log(obj01.constructor === obj) let arr = [] console.log(arr.constructor === Array) 4. isPrototypeOf 用法：Array.prototype.isPrototypeOf(arr) Array.prototype 属性表示 Array 构造函数的原型 其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上 let arr = [] console.log(Array.prototype.isPrototypeOf((arr))) 6. Object.getPrototypeOf 用法：Object.getPrototypeOf(arr) === Array.prototype Object.getPrototypeOf() 方法返回指定对象的原型 所以只需要跟Array的原型比较即可 7. Array.isArray 用法：Array.isArray(arr) ES5中新增了 Array.isArray 方法，IE8及以下不支持 let arr = [] console.log(Array.isArray(arr)) 5.2.2 转换方法 toString() 会返回数组元素的逗号拼接字符串 valueOf() 返回该数组 toLocaleString() 返回数组元素的逗号拼接字符串 注意：toString() 和 toLocaleString() 的区别，这是两个不同的方法，所有返回的值有可能会不通 let preson01 = { toLocaleString : ()=>{ return 'Zzhiren' }, toString : () => { return 'Tom' } } let person02 = { toLocaleString : () => { return 'Mini' }, toString : () => { return 'Tom' } } let people = [preson01, person02] alert(people) alert(people.toString()) alert(people.toLocaleString()) "},"练习题.html":{"url":"练习题.html","title":"练习题.md","keywords":"","body":"练习题 下面函数的最终打印顺序 function test() { setTimeout(function(){ console.log(1) }, 0); new Promise(function(a, b){ setTimeout(function(){ for(var i=0; i 解答 setTimeout 的时间参数最低为4ms，浏览器会将0改为4ms；js为单线程执行，当第一个setTimeout为延时执行后，js会立即执行后面的代码，此时执行到new Promise，其中的a和b方法就是promise的两个回调resolve（成功后执行的方法，then）和reject（错误后执行的方法catch）// 2,4,1,3 "}}